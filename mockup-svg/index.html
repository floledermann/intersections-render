<!doctype html>
<head>
<title>Line intersection test</title>
<link rel="icon" href="data:,">
<style>
html {
  background-color: #000000;
  color: #ffffff;
  font-size: 12px;
}

select {
  font-size: 12px;
}

h2 {
  margin: 5px 0;
}

.hblock {
  display: inline-block;
  vertical-align: top;
  border: 1px solid #fff;
  border-radius: 5px;
  padding: 5px;
  margin: 5px;
}

.vblock {
  display: block;
  border: 1px solid #fff;
  border-radius: 5px;
  padding: 5px;
  margin: 5px 0;
}

svg {
  margin: 5px;
}

svg .lane.car {
  fill: #eeeeee;
}

svg .lane.pedestrian {
  fill: #cccccc;
}

svg .lane.cycle {
  fill: #ffdddd;
}

svg .lane.parking {
  fill: #eeeeff;
}

svg .lane.green {
  fill: #99dd99;
}

button {
  cursor: pointer;
}
</style>
</head>
<body>

<section id="ui-wrapper">
</section>

<section id="viz-wrapper">
</section>

<template id="streetSettingsGUI">
<div class="streetUI hblock">
  <h2>StreetName</h2>
  <div>
    <label for="angle">Angle</label>
    <input type="range" id="angle" name="angle" min="-180" max="180">
    <span class="value"></span> °
  </div>
  <div class="lanesWrapper">
  </div>
  <div>
    <button name="addLane" title="Add lane">+</button>
  </div>
</div>
</template>

<template id="laneSettingsGUI">
<div class="laneUI vblock">
  <div>
    <label for="type">Type</label>
    <select id="type" name="type"></select>
    <button name="deleteLane" title="Delete lane">-</button>
  </div>
  <div>
    <label for="width">Width</label>
    <input type="range" id="width" name="width" min="1" max="100">
    <span class="value"></span> px
  </div>
</div>
</template>

<script type="module">

import { vMult, vAdd, vSub, vLen, vUnit, 
         intersect, intersectDist, tangentPoints, 
         degRad, radDeg,
         normalizeAngle, normalizeAngle180, normalizeAngle90 } from "./vecMath.js";

let laneTypes = {
  "car": {
    label: "Lane for cars",
    options: [
      { name: "width", type: "integer", defaultValue: 30 },
      { name: "curb", type: "boolean", defaultValue: false },
      { name: "paint", type: "boolean", defaultValue: true },
      { name: "direction", choices: ["forward", "backward", "both"], defaultValue: "forward" },
    ]
  },
  "car-access": {
    label: "Car access (e.g. garage)",
    options: [
      { name: "width", type: "integer", defaultValue: 20 },
    ]
  },
  "pedestrian": {
    label: "Pedestrian (e.g. sidewalk)",
    options: [
      { name: "width", type: "integer", defaultValue: 15 },
    ]
  },
  "cycle": {
    label: "Cycling (dedicated)",
    options: [
      { name: "width", type: "integer", defaultValue: 20 },
      { name: "surface", 
        choices: ["asphalt","concrete","paving_stones","cobblestone","gravel","ground"], 
        defaultValue: "asphalt" 
      },
      { name: "smoothness", choices: ["excellent","good","intermediate","bad"] },
    ]
  },
  "cycle-shared": {
    label: "Cycling (shared with cars)",
    options: [
      { name: "width", type: "integer", defaultValue: 15 },  // width depends on type
    ]
  },
  "parking": {
    label: "Parking",
    options: [
      { name: "width", type: "integer", defaultValue: 30 },  // width depends on type
      { name: "orientation", choices: ["parallel","diagonal","orthogonal"], defaultValue: "parallel" },
    ]
  },
  "green": {
    label: "Grass",
    options: [
      { name: "width", type: "integer", defaultValue: 30 },  // width depends on type
    ]
    
  },
  "bus": {
    label: "Bus",
    options: [
      { name: "width", type: "integer", defaultValue: 40 },
    ]
  },
  // what about shared tram?
  "tram": {
    label: "Tram / rail",
    options: [
      { name: "width", type: "integer", defaultValue: 30 },
    ]
  }
}

// extract default vlues into a simple dict structure
let laneDefaults = 
  Object.fromEntries(
    Object.entries(laneTypes).map(
      ([laneType, laneProps]) => [laneType, 
        Object.fromEntries(
          (laneProps.options || []).map(
            options => [options.name, options.defaultValue]
          )
        )
      ]
    )
  );

let lanePriorities = [
  "rail",
  "car",
  "cycle",
  "pedestrian",
  "car-access",
  "green",
  "parking",
  // what to do with bus and tram
];

let state = {
  settings: {
  },
  streets: [
    {
      angle: -22,
      lanes: [
        {
          type: "pedestrian",
          curb: true,
          boundary: "building",
        },
        {
          type: "parking",
          paint: true,
          orientation: "parallel"
        },
        {
          type: "car",
          paint: true,
          direction: "backward",
        },          
        {
          type: "car",
          paint: true,
          direction: "forward",
        },          
        {
          type: "parking",
          paint: true,
          orientation: "diagonal",
        },
        {
          type: "cycle",
          curb: true,
          color: "red",
          oneway: false
        },
      ],
    },
    {
      angle: 180,
      lanes: [
        {
          type: "pedestrian",
          curb: true,
          boundary: "building",
          curbHeight: 15,
        },
        {
          type: "parking",
          paint: true,
          orientation: "parallel"
        },
        {
          type: "car",
          paint: true,
          direction: "backward",
        },          
        {
          type: "car",
          paint: true,
          direction: "forward",
        },          
        {
          type: "parking",
          paint: true,
          orientation: "diagonal",
        },
        {
          type: "cycle",
          curb: true,
          color: "red",
          oneway: false
        },
      ],
    },
    {
      angle: 90,
      lanes: [
        {
          type: "pedestrian",
          curb: true,
          boundary: "building",
          curbHeight: 15,
        },
        {
          type: "car",
          paint: true,
          direction: "backward",
        },          
        {
          type: "parking",
          paint: true,
          orientation: "diagonal",
        },
        {
          type: "pedestrian",
          curb: true,
          boundary: "building",
          curbHeight: 15,
        },
      ],
    },
    {
      angle: 260,
      lanes: [
        {
          type: "pedestrian",
          curb: true,
          boundary: "building",
          curbHeight: 15,
        },
        {
          type: "car",
          paint: true,
          direction: "backward",
        },          
        {
          type: "parking",
          paint: true,
          orientation: "diagonal",
        },
        {
          type: "pedestrian",
          curb: true,
          boundary: "building",
          curbHeight: 15,
        },
      ],
    },
  ],
  visualizations: [
    { 
      width: 600,
      height: 600,
      algorithm: "test1"
    },
    //{ algorithm: "test1" }
  ]
}

const svgNS = "http://www.w3.org/2000/svg";
  
function svgEl(tagName, attributes, parent) {
  let el = document.createElementNS(svgNS, tagName);
  for (let [n,v] of Object.entries(attributes)) {
    el.setAttribute(n, v);
  }
  if (parent) {
    parent.appendChild(el);
  }
  return el;
}
  
let algorithms = {
  test1: {
    generate: function(wrapper, state) {
    
      const INVALID_CUTOFF_ANGLE = 43;
      const STRAIGHT_ANGLE = 45;
    
      let streetsGeom = [];
      for (let street of state.streets) {
        let geom = {
          angle: street.angle,
          end: [0,0],
          length: street.length || 280,
          lanesGeom: [],
          street: street,
          invalid: false,
        };
        geom.start = [
          -geom.length * Math.cos(degRad(geom.angle)),
          -geom.length * Math.sin(degRad(geom.angle))
        ];
        geom.vector = vSub(geom.end, geom.start);
        geom.unit = vMult(geom.vector, 1/geom.length);
        geom.normal = [geom.unit[1], -geom.unit[0]];
        
        
        // figure out relationship of other streets
        // order by angle, check if left, straight continuation or right
        let otherStreets = [];
        for (let s of state.streets) {
          if (s == street) continue;
          let relAngle = normalizeAngle(s.angle - street.angle);
          let rel = (relAngle <= INVALID_CUTOFF_ANGLE || relAngle >= 360 - INVALID_CUTOFF_ANGLE) ? "invalid" :
                    (relAngle >= STRAIGHT_ANGLE && relAngle <= 180 - STRAIGHT_ANGLE) ? "left" :
                    (relAngle >= 180 - STRAIGHT_ANGLE && relAngle <= 180 + STRAIGHT_ANGLE) ? "straight" :
                    "right";
          if (rel == "invalid") {
            console.warn("Invalid crossing angle: " + relAngle + "°");
            geom.invalid = true;
          }

          otherStreets.push({
            rel,
            relAngle,
            streetGeom: geom
          });
        }
        otherStreets.filter(a => a.rel != "invalid")
        otherStreets.sort((a,b) => a.relAngle-b.relAngle);

        geom.otherStreets = otherStreets;
        
        let streetWidth = 0;
        
        for (let lane of street.lanes) {
          // store basic lane geometry
          let laneDef = Object.assign({}, laneDefaults[lane.type], lane);
          let laneWidth = laneDef.width || 20;
          
          geom.lanesGeom.push({
            width: laneWidth,
            offset: streetWidth,
            lane: lane
          });
          
          streetWidth += laneWidth;
        }
        
        geom.width = streetWidth;
        
        for (let laneGeom of geom.lanesGeom) {
          // start left, check clockwise with other streets
          laneGeom.offset -= streetWidth/2;
        }
        
        streetsGeom.push(geom);
      }
      
      streetsGeom.sort((a,b) => a.angle-b.angle);
      
      // first pass finished 
      //   - relative street angles
      //   - angle classification (left, stright, right, invalid)
      //   - lane y' position
      
      // assumption: each lane has only one continuation in each other street

      // second pass:
      //   - establish lanes x' end
      for (let sGeom of streetsGeom) {
      /*
        let firstLeft = sGeom.otherStreets[0];
        if (firstLeft.rel != "left") firstLeft = null;
        let firstRight = sGeom.otherStreets[sGeom.otherStreets.length-1]
        if (firstRight.rel != "right") firstRight = null;
        */
        let continuationStreets = sGeom.otherStreets;
        for (let lGeom of sGeom.lanesGeom) {
          let { laneGeom, streetRel, stop } = findContinuationOrStop(lGeom, continuationStreets);
          
          // subsequent lanes continue from same street or further clockwise
          continuationStreets = sGeom.otherStreets.slice(sGeom.otherStreets.indexOf(streetRel));
          
          if (stop) {
            lGeom.endX = -100;
          }
          else {
            lGeom.endX = 0;
          }
          
        }
      }
      
      console.log(streetsGeom);
      
      // returns { laneGeom, streetRel, stop}
      function findContinuationOrStop(laneGeom, otherStreets) {
      
        for (let otherStreetRel of otherStreets) {
          let otherLanes = otherStreetRel.streetGeom.lanesGeom;
          // make copy and reverse order if not left turn
          if (otherStreetRel.rel != "left") Array.from(otherLanes).reverse();
          for (let otherLaneGeom of otherLanes) {
            if (laneGeom.lane.type == otherLaneGeom.lane.type) {
              return { laneGeom: otherLaneGeom, streetRel: otherStreetRel, stop: false }
            }
            if (lanePriorities.indexOf(laneGeom.lane.type) > lanePriorities.indexOf(otherLaneGeom.lane.type)) {
              return { laneGeom: otherLaneGeom, streetRel: otherStreetRel, stop: true }
            }
          }
        }
        // should this ever happen?
        throw "Neither continuation nor stop lane found";
        return { laneGeom: null, streetRel: null, stop: true }
      }
      
      for (let sGeom of streetsGeom) {
        svgEl("circle", {r: 5, cx: sGeom.start[0], cy: sGeom.start[1], fill: "#f00"}, wrapper);
        svgEl("circle", {r: 5, cx: sGeom.end[0], cy: sGeom.end[1], fill: "#f00"}, wrapper);
        svgEl("rect", {
          transform: `translate(${sGeom.start.join(",")}) rotate(${sGeom.angle})`,
          x: 0,
          y: -sGeom.width/2,
          height: sGeom.width + 1,
          width: sGeom.length,
          fill: "none",
          "stroke": sGeom.invalid ? "#ff0000" : "#000000",
          "stroke-width": sGeom.invalid ? 2 : 0.5,
          "stroke-dasharray": "8 3"
        }, wrapper);
        
        if (sGeom.invalid) continue;
        
        let lanesGroup = svgEl("g", {
          "class": "lanes",
          transform: `translate(${sGeom.start.join(",")}) rotate(${sGeom.angle}) translate(0,0)`, // ${-sGeom.width/2}
        }, wrapper);
        for (let lGeom of sGeom.lanesGeom) {
          svgEl("rect", {
            x: 2,
            y: lGeom.offset + 2,
            height: lGeom.width - 3,
            width: sGeom.length + lGeom.endX - 4,
            "class": "lane " + lGeom.lane.type,
            fill: "none",
            //"stroke": "#000000",
            "stroke-width": 0.5,
            "stroke-dasharray": "2 4"
          }, lanesGroup);      
        }
        
      }
      
    }
  },
  test2: {
  }
}

function buildUI(state, wrapper, update) {

  function wireSliders(wrapper, data, update) {
  
    for (let slider of wrapper.querySelectorAll("input[type=range]")) {

      slider.value = data[slider.name];

      let valEl = slider.parentElement.querySelector(".value");
      if (valEl) {
        valEl.textContent = slider.value;
        slider.addEventListener("input", e => valEl.textContent = e.target.value);
        if (update) slider.addEventListener("input", e => update(e.target.name, e.target.value));
      }
    }
 }

  let streetUiTemplate = document.getElementById("streetSettingsGUI").content.firstElementChild;
  let laneUiTemplate = document.getElementById("laneSettingsGUI").content.firstElementChild;

  for (let street of state.streets) {
  
    let streetUI = streetUiTemplate.cloneNode(true);
    wrapper.appendChild(streetUI);
    
    let lanesWrapper = streetUI.querySelector(".lanesWrapper");

    wireSliders(streetUI, street, (name, val) => {street[name] = +val; update(state)});
        
    for (let lane of street.lanes) {
    
      Object.assign(lane, laneDefaults[lane.type], lane);
    
      let laneUI = laneUiTemplate.cloneNode(true);
      lanesWrapper.appendChild(laneUI);
      
      wireSliders(laneUI, lane, (name, val) => {lane[name] = +val; update(state)});
    
      let sel = laneUI.querySelector("#type");
      for (let [type, options] of Object.entries(laneTypes)) {
        let option = document.createElement("option");
        option.value = type;
        option.textContent = options.label;
        if (type == lane.type) option.selected = true;
        sel.appendChild(option);
      }
      sel.addEventListener("input", e => {
        lane[e.target.name] = e.target.value;
        update(state);
      });
    }
  }
  
  return function updateUI(newState) {
  }

}

function buildSVG(state, wrapper, update) {

  let svgs = [];

  for (let viz of state.visualizations) {
  
    let width = viz.width || 500;
    let height = viz.height || 500;
  
    let svg = svgEl("svg", {
      width: width,
      height: height,
      viewBox: `${-width/2} ${-height/2} ${width} ${height}`,
      fill: "#ffffff"
    }, wrapper);
    
    svgEl("rect", {
      x: "-50%",
      y: "-50%",
      width: "100%",
      height: "100%",
      fill: "#ffffff"
    }, svg);
    
    let vizWrapper = svgEl("g", {"class":"viz"}, svg);
    
    svgs.push(vizWrapper);
    
  }
  
  return function updateSVG(state) {
    
    let i=0;
    
    for (let viz of state.visualizations) {
      svgs[i].innerHTML = "";
      algorithms[viz.algorithm].generate(svgs[i], state);
      i++;
    }
  }
}

let updateSVG = buildSVG(state, document.getElementById("viz-wrapper"));

updateSVG(state);

let updateUI = buildUI(state, document.getElementById("ui-wrapper"), updateSVG);

</script>

</body>
</html>