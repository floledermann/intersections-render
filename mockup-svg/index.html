<!doctype html>
<head>
<title>Line intersection test</title>
<link rel="icon" href="data:,">
<link rel="stylesheet" href="style.css">
</head>

<body>

<section id="ui-wrapper">
</section>

<section id="viz-wrapper">
</section>

<section id="notes">
<h3>To Do</h3>
<ul>
<li>collection of test cases</li>
<li>construct crossings (Zebra / bicycle)</li>
<li>what to do with bus and tram?</li>
<li>align streets by specific lanes</li>
<li>point features in lanes (trees, traffic islands)</li>
</ul>
</section>

<template id="streetSettingsGUI">
<div class="streetUI hblock">
  <h2>StreetName</h2>
  <div>
    <label for="angle">Angle</label>
    <input type="range" id="angle" name="angle" min="-360" max="360">
    <span class="value"></span> Â°
  </div>
  <div class="lanesWrapper">
  </div>
  <!--
  <div>
    <button name="addLane" title="Add lane">+</button>
  </div>
  -->
</div>
</template>

<template id="laneSettingsGUI">
<div class="laneUI vblock">
  <div>
    <label for="type">Type</label>
    <select id="type" name="type"></select>
    <button name="deleteLane" title="Delete lane">-</button>
  </div>
  <div>
    <label for="width">Width</label>
    <input type="range" id="width" name="width" min="1" max="100">
    <span class="value"></span> px
  </div>
</div>
</template>

<script type="module">

import { svgEl } from "./svgUtil.js";

import intersectionTopology from "./intersectionTopology.js";
import intersectionGeometry from "./intersectionGeometry.js";
import { render as svgRender } from "./svgRender.js";
                  
import testcases from "./testcases.js";

let laneTypes = {
  "car": {
    label: "Lane for cars",
    options: [
      { name: "width", type: "integer", defaultValue: 30 },
      { name: "curb", type: "boolean", defaultValue: false },
      { name: "paint", type: "boolean", defaultValue: true },
      { name: "direction", choices: ["forward", "backward", "both"], defaultValue: "forward" },
    ]
  },
  "car-access": {
    label: "Car access (e.g. garage)",
    options: [
      { name: "width", type: "integer", defaultValue: 20 },
    ]
  },
  "pedestrian": {
    label: "Pedestrian (e.g. sidewalk)",
    options: [
      { name: "width", type: "integer", defaultValue: 15 },
    ]
  },
  "cycle": {
    label: "Cycling (dedicated)",
    options: [
      { name: "width", type: "integer", defaultValue: 20 },
      { name: "surface", 
        choices: ["asphalt","concrete","paving_stones","cobblestone","gravel","ground"], 
        defaultValue: "asphalt" 
      },
      { name: "smoothness", choices: ["excellent","good","intermediate","bad"] },
    ]
  },
  "cycle-shared": {
    label: "Cycling (shared with cars)",
    options: [
      { name: "width", type: "integer", defaultValue: 15 },  // width depends on type
    ]
  },
  "parking": {
    label: "Parking",
    options: [
      { name: "width", type: "integer", defaultValue: 30 },  // width depends on type
      { name: "orientation", choices: ["parallel","diagonal","orthogonal"], defaultValue: "parallel" },
    ],
    "continue": "straight",
    retractFromCrossing: 50, // 
  },
  "green": {
    label: "Grass",
    options: [
      { name: "width", type: "integer", defaultValue: 30 },  // width depends on type
    ]
    
  },
  "bus": {
    label: "Bus",
    options: [
      { name: "width", type: "integer", defaultValue: 40 },
    ]
  },
  // what about shared tram?
  "tram": {
    label: "Tram / rail",
    options: [
      { name: "width", type: "integer", defaultValue: 30 },
    ]
  }
}

// extract default values into a simple dict structure
let laneDefaults = 
  Object.fromEntries(
    Object.entries(laneTypes).map(
      ([laneType, laneProps]) => [laneType, 
        Object.fromEntries(
          (laneProps.options || []).map(
            options => [options.name, options.defaultValue]
          )
        )
      ]
    )
  );

let lanePriorities = [
  "rail",
  "car",
  "cycle",
  "pedestrian",
  "car-access",
  "green",
  "parking",
  // what to do with bus and tram?
];

let state = {
  settings: testcases[0].settings,
  streets: testcases[0].streets,
  intersection: testcases[0].intersection,
  style: {
    defaultWidth: l => l.width,
    /*
    widths: {
      car: 15,
      cycle: 70,
      pedestrian: 5,
      "car-access": 15,
      green: 15,
      parking: 15,
    }
    */
  },
  visualizations: [
    { 
      width: 600,
      height: 600,
      // style: ...
    },
    //{ algorithm: "test1" }
  ]
}

function generateGeometry(streets, options) {

  let streetsGeom = intersectionTopology(streets, options);

  console.log(streetsGeom);

  streetsGeom = intersectionGeometry(streetsGeom, options);
  
  return streetsGeom;
}
    


function buildUI(state, wrapper, update) {

  function wireSliders(wrapper, data, update) {
  
    for (let slider of wrapper.querySelectorAll("input[type=range]")) {

      slider.value = data[slider.name];

      let valEl = slider.parentElement.querySelector(".value");
      if (valEl) {
        valEl.textContent = slider.value;
        slider.addEventListener("input", e => valEl.textContent = e.target.value);
        if (update) slider.addEventListener("input", e => update(e.target.name, e.target.value));
      }
    }
 }

  let streetUiTemplate = document.getElementById("streetSettingsGUI").content.firstElementChild;
  let laneUiTemplate = document.getElementById("laneSettingsGUI").content.firstElementChild;

  for (let street of state.streets) {
  
    let streetUI = streetUiTemplate.cloneNode(true);
    wrapper.appendChild(streetUI);
    
    let lanesWrapper = streetUI.querySelector(".lanesWrapper");

    wireSliders(streetUI, street, (name, val) => {street[name] = +val; update(state)});
        
    for (let lane of street.lanes) {
    
      // assign defaults to original lane data
      // TODO: this should be done elsewhere
      let laneWithDefaults = Object.assign({}, laneDefaults[lane.type], lane);
      Object.assign(lane, laneWithDefaults);
      
      let laneUI = laneUiTemplate.cloneNode(true);
      lanesWrapper.appendChild(laneUI);
      
      wireSliders(laneUI, lane, (name, val) => {lane[name] = +val; update(state)});
    
      let sel = laneUI.querySelector("#type");
      for (let [type, options] of Object.entries(laneTypes)) {
        let option = document.createElement("option");
        option.value = type;
        option.textContent = options.label;
        if (type == lane.type) option.selected = true;
        sel.appendChild(option);
      }
      sel.addEventListener("input", e => {
        lane[e.target.name] = e.target.value;
        update(state);
      });
    }
  }
  
  return function updateUI(newState) {
  }

}

function buildSVG(state, wrapper, update) {

  let svgs = [];

  for (let viz of state.visualizations) {
  
    let width = viz.width || 500;
    let height = viz.height || 500;
  
    let svg = svgEl("svg", {
      width: width,
      height: height,
      viewBox: `${-width/2} ${-height/2} ${width} ${height}`,
      fill: "#ffffff"
    }, wrapper);
    
    svgEl("rect", {
      x: "-50%",
      y: "-50%",
      width: "100%",
      height: "100%",
      fill: "#ffffff"
    }, svg);
    
    let vizWrapper = svgEl("g", {"class":"viz"}, svg);
    
    svgs.push(vizWrapper);
    
  }
  
  return function updateSVG(state) {
    
    let i=0;
    
    // compose options for geometry generation from various bits
    // TODO: clean this up
    let options = {
      ...state.intersection,
      laneDefaults,
      lanePriorities,
      style: state.style
    };
    
    for (let viz of state.visualizations) {
    
      let streetsGeom = generateGeometry(state.streets, options);
      
      svgs[i].innerHTML = "";
      svgRender(streetsGeom, svgs[i], {
        labels: false,
      });      
      i++;
    }
  }
}

let updateSVG = buildSVG(state, document.getElementById("viz-wrapper"));

updateSVG(state);

let updateUI = buildUI(state, document.getElementById("ui-wrapper"), updateSVG);

</script>

</body>
</html>